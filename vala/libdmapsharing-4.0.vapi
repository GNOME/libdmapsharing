/* libdmapsharing-4.0.vapi generated by vapigen, do not modify. */

namespace Dmap {
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class AvConnection : Dmap.Connection {
		[CCode (has_construct_function = false)]
		public AvConnection (string name, string host, uint port, Dmap.Db db, Dmap.RecordFactory factory);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class AvShare : Dmap.Share {
		[CCode (has_construct_function = false)]
		public AvShare (string name, string password, Dmap.Db db, Dmap.ContainerDb container_db, string transcode_mimetype);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class ChunkData {
		public weak GLib.InputStream original_stream;
		public weak Soup.Server server;
		public weak GLib.InputStream stream;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class Connection : GLib.Object {
		[CCode (has_construct_function = false)]
		protected Connection ();
		public void authenticate_message (Soup.Session session, Soup.Message message, Soup.Auth auth, string password);
		public virtual unowned Soup.Message build_message (string path, bool need_hash, double version, int req_id, bool send_close);
		public void disconnect (Dmap.ConnectionFunc callback);
		public bool @get (string path, bool need_hash, Dmap.ResponseHandler handler);
		public unowned Soup.MessageHeaders get_headers (string uri);
		public unowned GLib.SList get_playlists ();
		[NoWrapper]
		public virtual Dmap.ContentCode get_protocol_version_cc ();
		[NoWrapper]
		public virtual unowned string get_query_metadata ();
		[NoWrapper]
		public virtual unowned Dmap.Record handle_mlcl (Dmap.RecordFactory factory, GLib.Node mlcl, int item_id);
		public bool is_connected ();
		public void setup ();
		public void start (Dmap.ConnectionFunc callback);
		[NoAccessorMethod]
		public Soup.URI base_uri { owned get; set; }
		[NoAccessorMethod]
		public int database_id { get; set; }
		[NoAccessorMethod]
		public Dmap.Db db { owned get; construct; }
		[NoAccessorMethod]
		public double dmap_version { get; set; }
		[NoAccessorMethod]
		public Dmap.RecordFactory factory { owned get; construct; }
		[NoAccessorMethod]
		public string host { owned get; construct; }
		[NoAccessorMethod]
		public string name { owned get; construct; }
		[NoAccessorMethod]
		public string password { set; }
		[NoAccessorMethod]
		public uint port { get; construct; }
		[NoAccessorMethod]
		public int revision_number { get; set; }
		[NoAccessorMethod]
		public int session_id { get; set; }
		[NoAccessorMethod]
		public string username { owned get; construct; }
		public virtual signal void authenticate (string name, Soup.Session p1, Soup.Message p2, Soup.Auth p3, bool p4);
		public virtual signal void connected ();
		public virtual signal void connecting (ulong state, float progress);
		public virtual signal void disconnected ();
		public virtual signal void operation_done ();
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class ContentCodeDefinition {
		public Dmap.ContentCode code;
		public int32 int_code;
		public weak string name;
		[CCode (cname = "string")]
		public weak string str;
		public Dmap.Type type;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class ControlConnection : Dmap.Connection {
		[CCode (has_construct_function = false)]
		public ControlConnection (string name, string host, uint port, Dmap.Db db, Dmap.RecordFactory factory);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class ControlShare : Dmap.Share {
		[CCode (has_construct_function = false)]
		public ControlShare (string library_name, Dmap.ControlPlayer player, Dmap.Db db, Dmap.ContainerDb container_db);
		public void pair (string service_name, char[] passcode);
		public void player_updated ();
		public void start_lookup ();
		public void stop_lookup ();
		[NoAccessorMethod]
		public string library_name { owned get; set; }
		[NoAccessorMethod]
		public GLib.Object player { owned get; construct; }
		public virtual signal void add_guid (string guid);
		public virtual signal bool lookup_guid (string guid);
		public virtual signal void remote_found (string service_name, string remote_name);
		public virtual signal void remote_lost (string service_name);
		public virtual signal void remote_paired (string service_name, bool connected);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class DbFilterDefinition {
		public weak string key;
		public bool negate;
		public weak string value;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class GstInputStream : GLib.InputStream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "GInputStream*")]
		public GstInputStream (string transcode_mimetype, GLib.InputStream src_stream);
		[NoWrapper]
		public virtual void kill_pipeline ();
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class GstMP3InputStream : Dmap.GstInputStream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "GInputStream*")]
		public GstMP3InputStream (GLib.InputStream stream);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class GstQtInputStream : Dmap.GstInputStream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "GInputStream*")]
		public GstQtInputStream (GLib.InputStream stream);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class GstWavInputStream : Dmap.GstInputStream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "GInputStream*")]
		public GstWavInputStream (GLib.InputStream stream);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class HashContext {
		[CCode (array_length = false)]
		public weak uint32[] bits;
		[CCode (array_length = false)]
		public weak uint32[] buf;
		[CCode (array_length = false)]
		public weak uint[] @in;
		public int version;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class ImageConnection : Dmap.Connection {
		[CCode (has_construct_function = false)]
		public ImageConnection (string name, string host, uint port, Dmap.Db db, Dmap.RecordFactory factory);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class ImageShare : Dmap.Share {
		[CCode (has_construct_function = false)]
		public ImageShare (string name, string password, void* db, void* container_db, string transcode_mimetype);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class MdnsBrowser : GLib.Object {
		[CCode (has_construct_function = false)]
		public MdnsBrowser (Dmap.MdnsServiceType type);
		public static GLib.Quark error_quark ();
		public Dmap.MdnsServiceType get_service_type ();
		public unowned GLib.SList get_services ();
		public bool start () throws GLib.Error;
		public bool stop () throws GLib.Error;
		public virtual signal void service_added (Dmap.MdnsService service);
		public virtual signal void service_removed (string service);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class MdnsPublisher : GLib.Object {
		[CCode (has_construct_function = false)]
		public MdnsPublisher ();
		public static GLib.Quark error_quark ();
		public bool publish (string name, uint port, string type_of_service, bool password_required, string txt_records) throws GLib.Error;
		public bool rename_at_port (uint port, string name) throws GLib.Error;
		public bool withdraw (uint port) throws GLib.Error;
		public virtual signal void name_collision (string name);
		public virtual signal void published (string name);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class MdnsService : GLib.Object {
		[CCode (has_construct_function = false)]
		protected MdnsService ();
		[NoAccessorMethod]
		public string host { owned get; set; }
		[NoAccessorMethod]
		public string name { owned get; set; }
		[NoAccessorMethod]
		public string pair { owned get; set; }
		[NoAccessorMethod]
		public bool password_protected { get; set; }
		[NoAccessorMethod]
		public uint port { get; set; }
		[NoAccessorMethod]
		public string service_name { owned get; set; }
		[NoAccessorMethod]
		public uint transport_protocol { get; set; }
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class MdnsServiceService {
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class MetaDataMap {
		public uint md;
		public weak string tag;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class Playlist {
		public int id;
		public weak string name;
		public weak GLib.List uris;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public class Share : GLib.Object {
		[CCode (has_construct_function = false)]
		protected Share ();
		[NoWrapper]
		public virtual void add_entry_to_mlcl (uint id, Dmap.Record record, void* mb);
		[NoWrapper]
		public virtual void content_codes (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext ctx);
		[NoWrapper]
		public virtual void ctrl_int (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext ctx);
		[NoWrapper]
		public virtual void databases (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext context);
		[NoWrapper]
		public virtual void databases_browse_xxx (Soup.Server server, Soup.Message msg, string path, GLib.HashTable query, Soup.ClientContext context);
		[NoWrapper]
		public virtual void databases_items_xxx (Soup.Server server, Soup.Message msg, string path, GLib.HashTable query, Soup.ClientContext context);
		public static void free_filter (GLib.SList filter);
		[NoWrapper]
		public virtual uint get_desired_port ();
		[NoWrapper]
		public virtual void* get_meta_data_map ();
		[NoWrapper]
		public virtual unowned string get_type_of_service ();
		[NoWrapper]
		public virtual void login (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext ctx);
		[NoWrapper]
		public virtual void logout (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext ctx);
		[NoWrapper]
		public virtual void message_add_standard_headers (Soup.Message msg);
		[NoWrapper]
		public virtual void name_collision (Dmap.MdnsPublisher publisher, string name);
		[NoWrapper]
		public virtual void published (Dmap.MdnsPublisher publisher, string name);
		[NoWrapper]
		public virtual void server_info (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext ctx);
		[NoWrapper]
		public virtual void update (Soup.Server server, Soup.Message message, string path, GLib.HashTable query, Soup.ClientContext ctx);
		[NoAccessorMethod]
		public uint auth_method { get; set; }
		[NoAccessorMethod]
		public Dmap.ContainerDb container_db { owned get; construct; }
		[NoAccessorMethod]
		public Dmap.Db db { owned get; construct; }
		[NoAccessorMethod]
		public string name { owned get; set; }
		[NoAccessorMethod]
		public string password { owned get; set; }
		[NoAccessorMethod]
		public uint revision_number { get; set; }
		[NoAccessorMethod]
		public Soup.Server server { owned get; }
		[NoAccessorMethod]
		public string transcode_mimetype { owned get; construct; }
		[CCode (array_length = false, array_null_terminated = true)]
		[NoAccessorMethod]
		public string[] txt_records { owned get; set; }
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class StructureItem {
		public GLib.Value content;
		public Dmap.ContentCode content_code;
		public uint32 size;
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	[Compact]
	public class bitwise {
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public interface AvRecord : GLib.Object {
		public static int cmp_by_album (void* a, void* b, Dmap.Db db);
		public abstract bool itunes_compat ();
		public abstract unowned GLib.InputStream read () throws GLib.Error;
		[NoAccessorMethod]
		public int bitrate { get; set; }
		[NoAccessorMethod]
		public int disc { get; set; }
		[NoAccessorMethod]
		public int duration { get; set; }
		[NoAccessorMethod]
		public uint64 filesize { get; set; }
		[NoAccessorMethod]
		public int firstseen { get; set; }
		[NoAccessorMethod]
		public string format { owned get; set; }
		[NoAccessorMethod]
		public bool has_video { get; set; }
		[NoAccessorMethod]
		public GLib.Array hash { owned get; set; }
		[NoAccessorMethod]
		public string location { owned get; set; }
		[NoAccessorMethod]
		public Dmap.MediaKind mediakind { get; set; }
		[NoAccessorMethod]
		public int mtime { get; set; }
		[NoAccessorMethod]
		public int rating { get; set; }
		[NoAccessorMethod]
		public string songalbum { owned get; set; }
		[NoAccessorMethod]
		public int64 songalbumid { get; set; }
		[NoAccessorMethod]
		public string songartist { owned get; set; }
		[NoAccessorMethod]
		public string songgenre { owned get; set; }
		[NoAccessorMethod]
		public string sort_album { owned get; set; }
		[NoAccessorMethod]
		public string sort_artist { owned get; set; }
		[NoAccessorMethod]
		public string title { owned get; set; }
		[NoAccessorMethod]
		public int track { get; set; }
		[NoAccessorMethod]
		public int year { get; set; }
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", type_cname = "DmapContainerDbInterface")]
	public interface ContainerDb : GLib.Object {
		public abstract void add (Dmap.ContainerRecord record);
		public abstract int64 count ();
		public abstract void @foreach (Dmap.IdContainerRecordFunc func);
		public abstract unowned Dmap.ContainerRecord lookup_by_id (uint id);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public interface ContainerRecord : GLib.Object {
		public abstract void add_entry (Dmap.Record record, int id);
		public abstract unowned Dmap.Db get_entries ();
		public abstract uint64 get_entry_count ();
		public abstract uint get_id ();
		[NoAccessorMethod]
		public string name { owned get; set; }
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", type_cname = "DmapControlPlayerInterface")]
	public interface ControlPlayer : GLib.Object {
		public abstract void cue_clear ();
		public abstract void cue_play (GLib.List records, uint index);
		public abstract void next_item ();
		public abstract unowned uchar[] now_playing_artwork (uint width, uint height);
		public abstract unowned Dmap.AvRecord now_playing_record ();
		public abstract void pause ();
		public abstract void play_pause ();
		public abstract void prev_item ();
		[NoAccessorMethod]
		public Dmap.DACPPlayState play_state { get; set; }
		[NoAccessorMethod]
		public ulong playing_time { get; set; }
		[NoAccessorMethod]
		public Dmap.DACPRepeatState repeat_state { get; set; }
		[NoAccessorMethod]
		public bool shuffle_state { get; set; }
		[NoAccessorMethod]
		public ulong volume { get; set; }
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", type_cname = "DmapDbInterface")]
	public interface Db : GLib.Object {
		public abstract uint add (Dmap.Record record);
		public abstract uint add_path (string path);
		public abstract uint add_with_id (Dmap.Record record, uint id);
		public unowned GLib.HashTable apply_filter (GLib.SList filter_def);
		public abstract int64 count ();
		public abstract void @foreach (Dmap.IdRecordFunc func);
		public abstract unowned Dmap.Record lookup_by_id (uint id);
		public abstract uint lookup_id_by_location (string location);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", type_cname = "DmapImageRecordInterface")]
	public interface ImageRecord : GLib.Object {
		public abstract unowned GLib.InputStream read () throws GLib.Error;
		[NoAccessorMethod]
		public string aspect_ratio { owned get; set; }
		[NoAccessorMethod]
		public string comments { owned get; set; }
		[NoAccessorMethod]
		public int creation_date { get; set; }
		[NoAccessorMethod]
		public string filename { owned get; set; }
		[NoAccessorMethod]
		public string format { owned get; set; }
		[NoAccessorMethod]
		public GLib.Array hash { owned get; set; }
		[NoAccessorMethod]
		public int large_filesize { get; set; }
		[NoAccessorMethod]
		public string location { owned get; set; }
		[NoAccessorMethod]
		public int pixel_height { get; set; }
		[NoAccessorMethod]
		public int pixel_width { get; set; }
		[NoAccessorMethod]
		public int rating { get; set; }
		[NoAccessorMethod]
		public GLib.Array thumbnail { owned get; set; }
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", type_cname = "DmapRecordInterface")]
	public interface Record : GLib.Object {
		public abstract bool set_from_blob (GLib.Array blob);
		public abstract unowned GLib.Array to_blob ();
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", type_cname = "DmapRecordFactoryInterface")]
	public interface RecordFactory : GLib.Object {
		public abstract Dmap.Record create (void* user_data);
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_")]
	public enum ConnectionState {
		GET_INFO,
		LOGIN,
		GET_REVISION_NUMBER,
		GET_DB_INFO,
		GET_SONGS,
		GET_PLAYLISTS,
		GET_PLAYLIST_ENTRIES,
		LOGOUT,
		DONE
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_", has_type_id = false)]
	public enum ContentCode {
		CC_INVALID,
		RAW,
		CC_MDCL,
		CC_MSTT,
		CC_MIID,
		CC_MINM,
		CC_MIKD,
		CC_MPER,
		CC_MCON,
		CC_MCTI,
		CC_MPCO,
		CC_MSTS,
		CC_MIMC,
		CC_MCTC,
		CC_MRCO,
		CC_MTCO,
		CC_MLCL,
		CC_MLIT,
		CC_MBCL,
		CC_MSRV,
		CC_MSAU,
		CC_MSLR,
		CC_MPRO,
		CC_MSAL,
		CC_MSUP,
		CC_MSPI,
		CC_MSEX,
		CC_MSBR,
		CC_MSQY,
		CC_MSIX,
		CC_MSRS,
		CC_MSTM,
		CC_MSDC,
		CC_MCCR,
		CC_MCNM,
		CC_MCNA,
		CC_MCTY,
		CC_MLOG,
		CC_MLID,
		CC_MUPD,
		CC_MUSR,
		CC_MUTY,
		CC_MUDL,
		CC_MSMA,
		CC_FQUESCH,
		CC_APRO,
		CC_AVDB,
		CC_ABRO,
		CC_ABAL,
		CC_ABAR,
		CC_ABCP,
		CC_ABGN,
		CC_ADBS,
		CC_ASAL,
		CC_ASAI,
		CC_ASAA,
		CC_ASAR,
		CC_ASBT,
		CC_ASBR,
		CC_ASCM,
		CC_ASCO,
		CC_ASDA,
		CC_ASDM,
		CC_ASDC,
		CC_ASDN,
		CC_ASDB,
		CC_ASEQ,
		CC_ASFM,
		CC_ASGN,
		CC_ASDT,
		CC_ASRV,
		CC_ASSR,
		CC_ASSZ,
		CC_ASST,
		CC_ASSP,
		CC_ASTM,
		CC_ASTC,
		CC_ASTN,
		CC_ASUR,
		CC_ASYR,
		CC_ASDK,
		CC_ASUL,
		CC_ASSU,
		CC_ASSA,
		CC_APLY,
		CC_ABPL,
		CC_APSO,
		CC_PRSV,
		CC_ARIF,
		CC_MSAS,
		CC_AGRP,
		CC_AGAL,
		CC_ASCP,
		CC_PPRO,
		CC_PASP,
		CC_PFDT,
		CC_PICD,
		CC_PIMF,
		CC_PFMT,
		CC_PIFS,
		CC_PLSZ,
		CC_PHGT,
		CC_PWTH,
		CC_PRAT,
		CC_PCMT,
		CC_PRET,
		CC_AESV,
		CC_AEHV,
		CC_AESP,
		CC_AEPP,
		CC_AEPS,
		CC_AESG,
		CC_AEMK,
		CC_AEFP,
		CC_CMPA,
		CC_CMNM,
		CC_CMTY,
		CC_CMPG,
		CC_CACI,
		CC_CAPS,
		CC_CASH,
		CC_CARP,
		CC_CAAS,
		CC_CAAR,
		CC_CAIA,
		CC_CANP,
		CC_CANN,
		CC_CANA,
		CC_CANL,
		CC_CANG,
		CC_CANT,
		CC_CASP,
		CC_CASS,
		CC_CAST,
		CC_CASU,
		CC_CASG,
		CC_CACR,
		CC_CMCP,
		CC_CMGT,
		CC_CMIK,
		CC_CMSP,
		CC_CMST,
		CC_CMSV,
		CC_CMSR,
		CC_CMMK,
		CC_CMVO,
		CC_CMPR,
		CC_CAPR,
		CC_AEFR,
		CC_CAOV,
		CC_CMRL,
		CC_CAHP,
		CC_CAIV,
		CC_CAVC
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DACP_PLAY_")]
	public enum DACPPlayState {
		STOPPED,
		PAUSED,
		PLAYING
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DACP_REPEAT_")]
	public enum DACPRepeatState {
		NONE,
		SINGLE,
		ALL
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_MDNS_BROWSER_ERROR_")]
	public enum MdnsBrowserError {
		NOT_RUNNING,
		FAILED
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_MDNS_PUBLISHER_ERROR_")]
	public enum MdnsPublisherError {
		NOT_RUNNING,
		FAILED
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_MDNS_SERVICE_TRANSPORT_PROTOCOL_")]
	public enum MdnsServiceTransportProtocol {
		TCP,
		UDP,
		LAST
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_MDNS_SERVICE_TYPE_")]
	public enum MdnsServiceType {
		INVALID,
		DAAP,
		DPAP,
		DACP,
		RAOP,
		LAST
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_MEDIA_KIND_")]
	public enum MediaKind {
		MUSIC,
		MOVIE,
		PODCAST,
		TV_SHOW
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_SHARE_AUTH_METHOD_")]
	public enum ShareAuthMethod {
		NONE,
		NAME_AND_PASSWORD,
		PASSWORD
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cprefix = "DMAP_TYPE_")]
	public enum Type {
		BYTE,
		SIGNED_INT,
		SHORT,
		INT,
		INT64,
		STRING,
		DATE,
		VERSION,
		CONTAINER,
		POINTER,
		INVALID
	}
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public delegate bool ConnectionFunc (Dmap.Connection connection, bool result, string reason);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public delegate void IdContainerRecordFunc (uint id, Dmap.ContainerRecord record);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public delegate void IdRecordFunc (uint id, Dmap.Record record);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public delegate void ResponseHandler (Dmap.Connection connection, uint status, GLib.Node structure);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public const int HASH_SIZE;
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public const int HAVE_UNALIGNED_ACCESS;
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public const int SHARE_CHUNK_SIZE;
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public const int STATUS_OK;
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void chunked_message_finished (Soup.Message message, Dmap.ChunkData cd);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static Dmap.Type content_code_dmap_type (Dmap.ContentCode code);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned string content_code_name (Dmap.ContentCode code);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static Dmap.ContentCode content_code_read_from_buffer (string buf);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned string content_code_string (Dmap.ContentCode code);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static int32 content_code_string_as_int32 (string str);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned Dmap.ContentCodeDefinition content_codes (uint number);
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cname = "dmapd_input_stream_strdup_format_extension")]
	public static unowned string dmapd_input_stream_strdup_format_extension (int format_code);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void hash_generate (short version_major, uchar[] url, uchar hash_select, uchar[] @out, int request_id);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void hash_progressive_final (Dmap.HashContext context, uint[] digest);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void hash_progressive_init (Dmap.HashContext context);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void hash_progressive_to_string (uint digest, string str);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void hash_progressive_update (Dmap.HashContext context, uint buffer, uint length);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_BOOLEAN__STRING (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_STRING__STRING (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_STRING__ULONG_ULONG (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_ULONG__VOID (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_VOID__STRING_BOOLEAN (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_VOID__STRING_POINTER_POINTER_POINTER_BOOLEAN (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_VOID__STRING_STRING (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void marshal_generated_VOID__ULONG_FLOAT (GLib.Closure closure, GLib.Value return_value, uint n_param_values, GLib.Value param_values, void* invocation_hint, void* marshal_data);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned Avahi.Client mdns_avahi_get_client ();
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void mdns_avahi_set_entry_group (Avahi.EntryGroup group);
	[CCode (cheader_filename = "libdmapsharing/dmap.h", cname = "pads_compatible")]
	public static bool pads_compatible (Gst.Pad pad1, Gst.Pad pad2);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned GLib.Node structure_add (GLib.Node parent, Dmap.ContentCode cc);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void structure_destroy (GLib.Node structure);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned Dmap.StructureItem structure_find_item (GLib.Node structure, Dmap.ContentCode code);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned GLib.Node structure_find_node (GLib.Node structure, Dmap.ContentCode code);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static uint structure_get_size (GLib.Node structure);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void structure_increase_by_predicted_size (GLib.Node structure, uint size);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned GLib.Node structure_parse (string buf, int buf_length);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void structure_print (GLib.Node structure);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned string structure_serialize (GLib.Node structure, uint length);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static unowned string utils_mime_to_format (string transcode_mimetype);
	[CCode (cheader_filename = "libdmapsharing/dmap.h")]
	public static void write_next_chunk (Soup.Message message, Dmap.ChunkData cd);
}
